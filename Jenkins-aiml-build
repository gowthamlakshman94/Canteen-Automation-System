pipeline {
  agent {
    kubernetes {
      defaultContainer 'jnlp'
      yaml """
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: jnlp
    image: jenkins/inbound-agent:3345.v03dee9b_f88fc-3
    resources:
      requests:
        cpu: "250m"
        memory: "512Mi"
    volumeMounts:
      - name: workspace-volume
        mountPath: /home/jenkins/agent
  - name: kaniko
    image: gcr.io/kaniko-project/executor:debug
    command:
      - cat
    tty: true
    volumeMounts:
      - name: workspace-volume
        mountPath: /home/jenkins/agent
  nodeSelector:
    kubernetes.io/os: linux
  restartPolicy: Never
  volumes:
    - name: workspace-volume
      emptyDir: {}
"""
    }
  }

  parameters {
    string(name: 'VERSION', defaultValue: 'latest', description: 'Docker image tag (e.g., v1.0.0)')
    string(name: 'DOCKER_REGISTRY', defaultValue: 'ghcr.io', description: 'Docker Registry URL')
    string(name: 'GITHUB_OWNER', defaultValue: 'gowthamlakshman94', description: 'GH owner/org for the image path')
  }

  environment {
    DOCKER_CREDENTIAL_ID = 'ghcr-token'   // Jenkins credential (username/password)
    KANIKO_EXEC = '/kaniko/executor'
  }

  stages {
    stage('Checkout Code') {
      steps {
        echo "Cloning source code..."
        checkout scm
      }
    }

    stage('Prepare Docker Config (from Jenkins creds)') {
      steps {
        // create config.json in workspace using the jnlp container (shared volume)
        container('jnlp') {
          script {
            sh 'mkdir -p "${WORKSPACE}/.docker"'
            withCredentials([usernamePassword(credentialsId: env.DOCKER_CREDENTIAL_ID, usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
              sh '''
                set -e
                if command -v base64 >/dev/null 2>&1; then
                  AUTH=$(printf "%s:%s" "$DOCKER_USER" "$DOCKER_PASS" | base64 -w 0 2>/dev/null || printf "%s:%s" "$DOCKER_USER" "$DOCKER_PASS" | base64)
                else
                  AUTH=$(printf "%s:%s" "$DOCKER_USER" "$DOCKER_PASS" | openssl base64 -A)
                fi
                cat > "${WORKSPACE}/.docker/config.json" <<-JSON
                {
                  "auths": {
                    "${DOCKER_REGISTRY}": { "auth": "${AUTH}" }
                  }
                }
                JSON
              '''
            }
            sh 'ls -la ${WORKSPACE}/.docker || true'
            sh 'cat ${WORKSPACE}/.docker/config.json || true'  // masked in logs, but useful if you need to debug locally
          }
        }
      }
    }

    stage('Build & Push All Services (kaniko)') {
      steps {
        // run actions inside the kaniko container; it shares workspace via the emptyDir volume
        container('kaniko') {
          script {
            // Correct service paths from your repo (note underscores)
            def services = [
              [name: 'sales-forecaster', path: './sales_forecast'],
              [name: 'sales-dashboard', path: './sales_forecast_ui']
            ]

            // Copy docker config into Kaniko's expected location, then build each service
            // Ensure /kaniko/.docker exists and contains config.json
            sh '''
              set -e
              mkdir -p /kaniko/.docker
              cp -f "${WORKSPACE}/.docker/config.json" /kaniko/.docker/config.json
              ls -la /kaniko/.docker || true
            '''

            services.each { svc ->
              def repo = svc.name
              def ctx = svc.path
              def image = "${params.DOCKER_REGISTRY}/${params.GITHUB_OWNER}/${repo}:${params.VERSION}"

              echo "Building and pushing: ${image} (context: ${ctx})"
              sh "ls -la ${WORKSPACE}/${ctx} || true"

              // Run kaniko executor (no --docker-config flag)
              sh """
                ${KANIKO_EXEC} \\
                  --context ${WORKSPACE}/${ctx} \\
                  --dockerfile ${WORKSPACE}/${ctx}/Dockerfile \\
                  --destination=${image} \\
                  --cache=true \\
                  --verbosity=info
              """
              echo "Pushed: ${image}"
            }
          }
        }
      }
    }
  }

  post {
    success {
      echo "All images built and pushed successfully."
    }
    failure {
      echo "Build failed â€” check logs above. Common causes: missing Dockerfile, incorrect context path, or auth issues."
    }
  }
}
